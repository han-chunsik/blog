---
layout: post
title: "알고리즘 개념과 핵심 설계 기법"
date: 2025-05-12
categories: [algorithm, knou]
description: 알고리즘의 개념과 대표적인 설계 전략
comments: true
bird_image: "blue-footed-booby.webp"
bird_name: "푸른발 부비새 (Blue-footed booby)"
bird_scientific_name: "Sula nebouxii"
bird_description: "푸른발부비새는 동태평양의 바닷가와 섬에서 서식하는 바닷새로, 특히 갈라파고스 제도에서 많이 발견된다. 선명한 파란 발이 특징이다."
---

# 알고리즘

우리는 일상 속에서 수많은 문제를 해결하며 살아간다. 컴퓨터도 마찬가지다. 다양한 문제를 해결하기 위해 존재하며, 이를 위해 단순한 문법이나 언어 지식만으로는 부족하다. 문제를 해결하는 절차적 사고, 즉 알고리즘이 필요하다.

알고리즘은 주어진 문제를 해결하거나 특정 함수를 계산하기 위한 유한한 명령어들의 순서적 집합이다. 이는 코드로 작성되기 전, 해결 방법 자체를 논리적으로 정의한 것이라 볼 수 있다.

## 알고리즘의 필요 조건
1. **입출력 (Input/Output)**: 최소 하나 이상의 출력이 존재해야 한다.  
2. **명확성 (Definiteness)**: 각 단계는 명확하고 모호하지 않아야 한다.  
3. **유한성 (Finiteness)**: 유한한 단계 내에 종료되어야 한다.  
4. **유효성 (Effectiveness)**: 각 단계는 실제 실행 가능한 명령어여야 한다.  
5. **효율성 (Efficiency)**: 제한된 시간과 자원 내에 실행 가능해야 한다. 

## 알고리즘 설계 절차
1. **문제 정의 및 요구 분석**  
2. **해결 전략 수립** (의사코드, 순서도, 수학적 모델 등)  
3. **정확성 검증** (모든 입력에 대해 기대한 결과 도출 여부)  
4. **효율성 분석** (시간 복잡도, 공간 복잡도 평가)  
5. **코드 구현 및 테스트**

## 알고리즘 설계 기법
문제를 푸는 방식에는 여러 전략이 존재하며, 대표적으로 아래 세 가지가 많이 사용된다.

### 1. Greedy Algorithm (탐욕 기법)
#### 전략
- 매 단계마다 가장 최선이라고 판단되는 선택을 한다.
- 전체 최적해를 보장하지는 않지만, 빠르게 근사해를 구할 수 있다.

#### 장점
- 구현이 단순하고 빠르다.

#### 단점
- 항상 최적의 해를 보장하지 않는다.

#### 예시: 거스름돈 문제

```text
문제: 780원을 최소 개수의 동전으로 바꾸기 (동전: 500, 100, 50, 10)

→ 가장 큰 동전부터 greedy하게 선택  
→ 500 × 1 + 100 × 2 + 50 × 1 + 10 × 3 = 7개
```

단, 동전 종류가 [500, 120, 100, 10]일 경우 greedy 전략은 비효율적일 수 있다.

#### 예시: Fractional Knapsack (물건 쪼갤 수 있음)

```python
items = [(15, 3), (20, 5), (14, 4), (9, 3)]  # (이익, 무게)
items.sort(key=lambda x: x[0]/x[1], reverse=True)  # 단위 무게당 이익 기준 정렬
```

물건을 쪼갤 수 없는 경우(0/1 Knapsack)에는 부적합하다.

---

### 2. Divide and Conquer (분할 정복)

#### 전략
- 문제를 작게 나누어 푼 다음, 결과를 결합한다.
- 하위 문제들은 **서로 독립적**이어야 한다.

#### 장점
- 재귀적 접근이 자연스럽고, 병렬 처리가 가능하다.

#### 단점
- 하위 문제 간 중복이 많으면 비효율적이다.

#### 예시: 이진 탐색

```python
def binary_search(arr, key, left, right):
    if left > right:
        return -1
    mid = (left + right) // 2
    if arr[mid] == key:
        return mid
    elif key < arr[mid]:
        return binary_search(arr, key, left, mid - 1)
    else:
        return binary_search(arr, key, mid + 1, right)
```

- 분할: 배열을 절반으로 나눔  
- 정복: 절반 중 하나만 탐색  
- 결합: 결과를 반환 (병합 과정 없음)

#### 예시: 정렬 알고리즘
- 퀵 정렬 (Quick Sort)
- 병합 정렬 (Merge Sort)

---

### 3. Dynamic Programming (동적 계획법)

#### 전략
- 작은 문제의 결과를 저장하여 중복 계산을 피한다.
- **하위 문제가 중복**되며, **최적 부분 구조**를 가질 때 적합하다.

#### 장점
- 시간 효율이 높고, 최적의 결과를 보장한다.

#### 단점
- 상태 정의와 점화식 설계가 복잡할 수 있다.

#### 예시: 최장 공통 부분 수열 (LCS)

```python
def lcs(X, Y):
    m, n = len(X), len(Y)
    dp = [[0]*(n+1) for _ in range(m+1)]

    for i in range(m):
        for j in range(n):
            if X[i] == Y[j]:
                dp[i+1][j+1] = dp[i][j] + 1
            else:
                dp[i+1][j+1] = max(dp[i+1][j], dp[i][j+1])
    return dp[m][n]
```

#### 대표 문제
- 피보나치 수열 (memoization)
- 플로이드-워셜 (모든 정점 간 최단 거리)
- 행렬 곱셈 최적화

---

## 정리
알고리즘은 단순한 기술이 아니라 문제를 해결하는 사고의 틀이다. 문제의 구조와 제약 조건에 따라 적절한 설계 전략을 선택하고 적용함으로써, 효율적인 프로그램을 구현할 수 있다.
